#!/usr/bin/env node
/**
 * Push Prisma schema changes to Turso production database
 *
 * Run this after making changes to prisma/schema.prisma:
 *   node scripts/push-to-turso.js
 *
 * This script:
 * 1. Reads the current Turso schema
 * 2. Compares with Prisma schema
 * 3. Applies missing tables/columns
 */

const { createClient } = require('@libsql/client');
const fs = require('fs');
const path = require('path');

const TURSO_URL = 'libsql://caribou-po-unklesteve.aws-us-east-2.turso.io';
const TURSO_TOKEN = 'eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJhIjoicnciLCJpYXQiOjE3NjUxMjE3NDIsImlkIjoiZWJlMDc3ODMtNjViOS00M2M2LWEyODgtYWQwNDlhYjQyNDlkIiwicmlkIjoiNjljMWQyMzYtOWE5MS00NWE3LTk2ZmMtMmU2MmViMmJlNDNlIn0.737EYWRmmODxVLo1tCYggLj6BrAZ0Tb8mRVw1BjfGF0NGWJ2mGyhxRGkEsqoPqe3I5j9MUOlhDNj-akdvJBNBg';

const client = createClient({
  url: TURSO_URL,
  authToken: TURSO_TOKEN,
});

// Parse Prisma schema to extract models
function parsePrismaSchema() {
  const schemaPath = path.join(__dirname, '..', 'prisma', 'schema.prisma');
  const schema = fs.readFileSync(schemaPath, 'utf-8');

  const models = {};
  const modelRegex = /model\s+(\w+)\s*\{([^}]+)\}/g;
  let match;

  while ((match = modelRegex.exec(schema)) !== null) {
    const modelName = match[1];
    const body = match[2];
    const fields = [];

    const lines = body.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('//') && !l.startsWith('@@'));

    for (const line of lines) {
      // Parse field: name Type modifiers
      const fieldMatch = line.match(/^(\w+)\s+(\w+)(\?)?(\[\])?\s*(.*)?$/);
      if (fieldMatch) {
        const [, name, type, optional, array, rest] = fieldMatch;

        // Skip relation fields (they reference other models)
        if (models[type] || rest?.includes('@relation')) continue;

        fields.push({
          name,
          type,
          optional: !!optional,
          array: !!array,
          rest: rest || '',
        });
      }
    }

    models[modelName] = fields;
  }

  return models;
}

// Map Prisma types to SQLite types
function prismaToSqlite(prismaType, rest) {
  const isId = rest.includes('@id');
  const hasDefault = rest.includes('@default');

  switch (prismaType) {
    case 'String': return 'TEXT';
    case 'Int': return 'INTEGER';
    case 'Float': return 'REAL';
    case 'Boolean': return 'INTEGER'; // SQLite uses 0/1
    case 'DateTime': return 'DATETIME';
    default: return 'TEXT';
  }
}

// Get default value from Prisma @default
function getDefault(rest) {
  const match = rest.match(/@default\(([^)]+)\)/);
  if (!match) return null;

  const val = match[1];
  if (val === 'now()') return 'CURRENT_TIMESTAMP';
  if (val === 'true') return '1';
  if (val === 'false') return '0';
  if (val === 'cuid()' || val === 'uuid()') return null; // Generated by app
  if (val.startsWith('"') && val.endsWith('"')) return val; // String literal
  return val;
}

async function getExistingTables() {
  const result = await client.execute("SELECT name FROM sqlite_master WHERE type='table'");
  return result.rows.map(r => r.name);
}

async function getTableColumns(tableName) {
  const result = await client.execute(`PRAGMA table_info(${tableName})`);
  return result.rows.map(r => r.name);
}

async function main() {
  console.log('üîç Parsing Prisma schema...');
  const models = parsePrismaSchema();
  console.log(`   Found ${Object.keys(models).length} models\n`);

  console.log('üìä Checking Turso database...');
  const existingTables = await getExistingTables();
  console.log(`   Found ${existingTables.length} existing tables\n`);

  let changes = 0;

  for (const [modelName, fields] of Object.entries(models)) {
    const tableExists = existingTables.includes(modelName);

    if (!tableExists) {
      // Create table
      console.log(`üìù Creating table: ${modelName}`);

      const columns = fields.map(f => {
        const sqlType = prismaToSqlite(f.type, f.rest);
        const notNull = !f.optional && !f.rest.includes('@default') ? '' : '';
        const defaultVal = getDefault(f.rest);
        const defaultStr = defaultVal ? ` DEFAULT ${defaultVal}` : '';
        const primaryKey = f.rest.includes('@id') ? ' PRIMARY KEY' : '';

        return `${f.name} ${sqlType}${primaryKey}${notNull}${defaultStr}`;
      }).join(',\n        ');

      const sql = `CREATE TABLE IF NOT EXISTS ${modelName} (\n        ${columns}\n      )`;

      try {
        await client.execute(sql);
        console.log(`   ‚úÖ Created ${modelName}`);
        changes++;
      } catch (e) {
        console.log(`   ‚ùå Error: ${e.message}`);
      }
    } else {
      // Check for missing columns
      const existingColumns = await getTableColumns(modelName);

      for (const field of fields) {
        if (!existingColumns.includes(field.name)) {
          console.log(`üìù Adding column: ${modelName}.${field.name}`);

          const sqlType = prismaToSqlite(field.type, field.rest);
          const defaultVal = getDefault(field.rest);
          const defaultStr = defaultVal ? ` DEFAULT ${defaultVal}` : '';

          const sql = `ALTER TABLE ${modelName} ADD COLUMN ${field.name} ${sqlType}${defaultStr}`;

          try {
            await client.execute(sql);
            console.log(`   ‚úÖ Added ${field.name}`);
            changes++;
          } catch (e) {
            if (e.message.includes('duplicate column')) {
              // Already exists, skip
            } else {
              console.log(`   ‚ùå Error: ${e.message}`);
            }
          }
        }
      }
    }
  }

  if (changes === 0) {
    console.log('\n‚ú® Database is already in sync!');
  } else {
    console.log(`\n‚úÖ Applied ${changes} changes to Turso`);
  }

  console.log('\nüí° Remember to run: npx prisma generate');
}

main().catch(console.error);
